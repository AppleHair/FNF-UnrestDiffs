// TODO: Add more comments to this file
import funkin.modding.module.Module;
import funkin.modding.module.ModuleHandler;
import funkin.modding.PolymodErrorHandler;
import funkin.Paths;
import funkin.ui.freeplay.FreeplayState;
import funkin.data.song.SongRegistry;
import funkin.play.song.Song;
import funkin.util.Constants;
import funkin.util.tools.ArrayTools;
import haxe.ds.ArraySort;
import Int;
import openfl.utils.Assets;
import StringTools;

class DiffDefiner extends Module {

    function new() {
        super('diff-definer', 1);
    }

    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    var difficultyDefs:Array<Array<String>> = [
        ["easy","normal","hard","erect","nightmare"],
        ["1","3","5","7","9"]
    ];

    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    var variationDefs:Array<String> = ["default","erect"];
    var diffIndicesByVari:Array<Array<Int>> = [[0,1,2],[3,4]];

    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    /**
     * Used for tracking setup completion.
     */
    var finishedSetup:Bool = false;

    function sortDifficulties(a:String, b:String):Int {
        var numAd:Null<Int> = Std.parseInt(this.difficultyDefs[1][this.difficultyDefs[0].indexOf(a)]);
        var numBd:Null<Int> = Std.parseInt(this.difficultyDefs[1][this.difficultyDefs[0].indexOf(b)]);
        if (numAd == null || numBd == null) {return 0;}
        if (numAd < numBd) {
            return -1;
        }
        if (numAd > numBd) {
            return 1;
        }
        return 0;
    }

    function checkForDefinitionData(path:String, callback:(res:Array<String>) -> Void):Void {
        if (!Assets.exists(path)) {return;}
        for (line in Assets.getText(path).split("\n")) {
            if (line == "") {continue;}
            if (StringTools.startsWith(line, "//")) {continue;}
            callback(line.split(",").map(function(e:String):String {return StringTools.trim(e);}));
        }
    }

    function defineVariation(variId:String):Void {
        if (this.variationDefs.contains(variId)) {return;}
        this.variationDefs.push(variId);
        this.diffIndicesByVari.push([]);
    }

    function defineDifficulty(diffId:String, priority:String, ?variId:String):Void {
        if (variId == null && !this.difficultyDefs[0].contains(diffId)) {
            this.difficultyDefs[0].push(diffId);
            this.difficultyDefs[1].push(priority.split(".")[0]);
            return;
        }
        var variIndex:Int = this.variationDefs.indexOf(variId);
        if (variIndex == -1) {
            defineVariation(variId);
            variIndex = this.variationDefs.indexOf(variId);
        }
        if (this.difficultyDefs[0].contains(diffId)) {
            this.diffIndicesByVari[variIndex].push(this.difficultyDefs[0].indexOf(diffId));
            return;
        }
        this.difficultyDefs[0].push(diffId);
        this.difficultyDefs[1].push(priority.split(".")[0]);
        this.diffIndicesByVari[variIndex].push(this.difficultyDefs[0].length-1);
    }

    // Difficulties and variations MUST have
    // a One-to-many relationship per-song, meaning
    // that in every song, a variation can have many
    // difficulties, but a difficulty can only have
    // ONE variation.
    // This rule applies to all difficulties, except
    // for hidden ones (like "picospeaker") which exist
    // only in the chart files, and are not shown in game.
    var forRemovalDiffVALI:Array<String>;
    var forRemovalVariVALI:Array<String>;
    var songVALI:Song;
    var trackedDifficultiesVALI:Array<Array<String>>;
    function validateDifficulties():Void {
        for (songId in SongRegistry.instance.listBaseGameSongIds().concat(SongRegistry.instance.listModdedSongIds())) {
            songVALI = SongRegistry.instance.fetchEntry(songId);
            songVALI.difficulties.clear();
            songVALI.populateDifficulties();
            forRemovalVariVALI = [];
            trackedDifficultiesVALI = [[],[]];
            for (vari in songVALI.variations) {
                forRemovalDiffVALI = [];
                for (diff in songVALI._metadata.get(vari).playData.difficulties) {
                    if (trackedDifficultiesVALI[0].contains(diff)) {
                        // TODO: Make this check consider character selection when it's implemented
                        if (trackedDifficultiesVALI[1][trackedDifficultiesVALI[0].indexOf(diff)] != vari) {
                            var realVari:String = trackedDifficultiesVALI[1][trackedDifficultiesVALI[0].indexOf(diff)];
                            PolymodErrorHandler.showAlert("Variation-Difficulty Relationship Error", "Tried to add"+
                                " the difficulty \""+diff+"\" to the variation \""+vari+"\" in the song \""+songVALI.id+"\","+
                                " but the difficulty already had the \""+realVari+"\" variation assigned to it in this song.");
                            forRemovalDiffVALI.push(diff);
                        }
                        continue;
                    }
                    defineVariation(vari);
                    defineDifficulty(diff, "", vari);
                    trackedDifficultiesVALI[0].push(diff);
                    trackedDifficultiesVALI[1].push(vari);
                    // trackedDifficultiesVALI[2].push(charId);
                }
                for (diff in forRemovalDiffVALI) {
                    songVALI._metadata.get(vari).playData.difficulties.remove(diff);
                    var variationSuffix:String = (vari != Constants.DEFAULT_VARIATION) ? '-'+vari : '';
                    songVALI.difficulties.remove(diff+variationSuffix);
                }
                if (songVALI._metadata.get(vari).playData.difficulties.length == 0) {
                    forRemovalVariVALI.push(vari);
                }
            }
            for (vari in forRemovalVariVALI) {
                songVALI.variations.remove(vari);
                songVALI._metadata.remove(vari);
            }
        }
        songVALI = null;
        forRemovalDiffVALI = null;
        forRemovalVariVALI = null;
    }

    function setup():Void {
        if (this.finishedSetup) {return;}

        var UDPaths = ModuleHandler.getModule("ud-paths");

        checkForDefinitionData(Paths.txt(
        UDPaths.scriptCall("definitions", [false])),
        function(res:Array<String>):Void {
            if (res.length < 2) {return;}
            if (res.length < 3) {res.push('');}
            defineDifficulty(res[0], res[1]);
        });

        validateDifficulties();

        Constants.DEFAULT_DIFFICULTY_LIST = this.difficultyDefs[0].copy();
        ArraySort.sort(Constants.DEFAULT_DIFFICULTY_LIST, sortDifficulties);

        trace('[diff-sorter]  -  Finished Defining Difficulties and Variations!');

        this.finishedSetup = true;
    }

    public override function onCreate(event:ScriptEvent):Void {
        super.onCreate();
        setup();
    }

    public override function onStateChangeEnd(event:StateChangeScriptEvent):Void {
        super.onStateChangeEnd();
        setup();
    }

    var freeplayState:FreeplayState = null;

    public override function onSubStateOpenEnd(event:SubStateScriptEvent):Void {
        super.onSubStateOpenEnd();
        if (Std.isOfType(event.targetState, FreeplayState)) {
            freeplayState = event.targetState;
        }
    }

    public override function onUpdate(event:UpdateScriptEvent):Void {
        super.onUpdate();
        if (freeplayState != null) {
            ArraySort.sort(freeplayState.diffIdsTotal,sortDifficulties);
            freeplayState = null;
        }
    }
}