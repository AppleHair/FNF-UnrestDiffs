// TODO: Add more comments to this file
import flixel.addons.transition.FlxTransitionableState;
import flixel.FlxG;
import flixel.FlxSprite;
import flixel.tweens.FlxEase;
import flixel.tweens.FlxTween;
import flixel.util.FlxTimer;
import funkin.audio.FunkinSound;
import funkin.data.song.SongRegistry;
import funkin.data.story.level.LevelRegistry;
import funkin.modding.events.ScriptEvent;
import funkin.modding.module.Module;
import funkin.modding.module.ModuleHandler;
import funkin.Paths;
import funkin.play.PlayState;
import funkin.play.PlayStatePlaylist;
import funkin.save.Save;
import funkin.ui.story.Level;
import funkin.ui.story.StoryMenuState;
import funkin.ui.transition.LoadingState;
import funkin.util.assets.DataAssets;
import funkin.util.Constants;
import funkin.util.ReflectUtil;
import funkin.util.SortUtil;
import funkin.util.tools.ArrayTools;
import openfl.utils.Assets;
import StringTools;

/**
 * In order for this to work properly,
 * the base level's script needs to use
 * the template on docs/templates/LevelScriptTemplate.hxc
 */
class StoryDiffs extends Module {

    function new() {
        super('story-diffs', 1);
        if (StoryMenuState.rememberedLevelId != null) {
            this.lastRememberedLevelId = StoryMenuState.rememberedLevelId;
        }
    }

    // PLEASE DON'T MODIFY THESE VARIABLES!!!
    var ENTERED:String = "UD_STORY_ENTER";
    var SCROLLED:String = "UD_STORY_SCROLL";
    var CONFIRMED:String = "UD_STORY_CONFIRM";
    var EXITED:String = "UD_STORY_EXIT";

    // Used for defining the level alt data paths.
    // PLEASE DON'T MODIFY THESE VARIABLES!!!
    var BASE_PREFIX_LADP:String = "UD/injections/levels-alt/";
    var DIFFS_PREFIX_LADP:String = "difficulties/";
    var VARIS_PREFIX_LADP:String = "variations/";

    // Used for tracking level alt data.
    // PLEASE DON'T MODIFY THESE VARIABLES!!!
    var difficultiesToVariations:Array<Array<String>> = [[],[]];
    var defaultLevelDatas:Array<Array<Dynamic>> = [[],[]];
    var levelAltData:Array<Array<Dynamic>> = [[],[]];
    var hasAltData:Array<String> = [];

    // Used for tracking the story mode menu.
    // PLEASE DON'T MODIFY THESE VARIABLES!!!
    var storyMenu:StoryMenuState = null;
    var justEnteredStoryMenu:Bool = false;
    var lastRememberedDifficulty:String = StoryMenuState.rememberedDifficulty;
    var lastDifficultyList:Array<String> = Constants.DEFAULT_DIFFICULTY_LIST_FULL;
    var lastRememberedLevelId:String = Constants.DEFAULT_SONG;// "tutorial"

    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    /**
     * Used for tracking setup completion.
     */
    var finishedSetup:Bool = false;

    function dispatchEvent(event:ScriptEvent):Void {
        trace('[story-diffs]  -  Dispatching event ('+event.type+')');
        ModuleHandler.callEvent(event);
    }

    /**
     * Reloads the data of the level with new data,
     * while keeping the default data, so we could
     * reuse it later.
     * @param newData The level data to load.
     */
     function reloadData(level:Level, newData:Dynamic):Void {
        // don't load the same data twice
        if (newData == level._data) {return;}
        if (!this.defaultLevelDatas[0].contains(level.id)) {return;}

        var thisLevelData = this.defaultLevelDatas[1][this.defaultLevelDatas[0].indexOf(level.id)];

        level._data = newData;
        // I won't let you hide the level from
        // story mode if it's not already hidden.
        level._data.visible = thisLevelData.visible;
        // Adding songs to alt levels
        // gets handles somewhere else.
        level._data.songs = thisLevelData.songs;
    }


    /**
     * Resets the data of the level to the default data.
     * Used by the story-diffs module to reset the data
     * when an alt level data can't be found for the
     * current variation or difficulty.
     */
    function resetDataToDefault(level:Level):Void {
        if (!this.defaultLevelDatas[0].contains(level.id)) {
            this.defaultLevelDatas[0].push(level.id);
            this.defaultLevelDatas[1].push(Level._fetchData(level.id));
        }
        // resets the data to the default data
        level._data = this.defaultLevelDatas[1][this.defaultLevelDatas[0].indexOf(level.id)];
    }


    /**
     * Consider adding songs to the level's song list.
     * @param songs The list of song IDs to consider adding.
     */
    function considerAddingSongs(level:Level, songs:Array<String>):Void {
        if (songs == null) {return;}
        if (!this.defaultLevelDatas[0].contains(level.id)) {
            this.defaultLevelDatas[0].push(level.id);
            this.defaultLevelDatas[1].push(Level._fetchData(level.id));
        }
        var thisLevelData = this.defaultLevelDatas[1][this.defaultLevelDatas[0].indexOf(level.id)];
        // the song list needs to have all the songs the level
        // already has, and if the level already has all the songs
        // in the song list, we don't need to add them again.
        if (ArrayTools.isSuperset(thisLevelData.songs,songs) ||
            !ArrayTools.isSuperset(songs, level._data.songs)) {return;}

        // we'll use this array as a queue, where song's
        // from the songs array will be added to the queue
        // while we iterate through it.
        var accumulatedSongsQueue:Array<String> = [];
        for (songId in songs) {
            // if the song isn't already in the
            // level's song list, add it to the queue.
            if (thisLevelData.songs.indexOf(songId) == -1) {
                accumulatedSongsQueue.push(songId);
                continue;
            }
            // otherwise, insert the songs accumulated in the queue
            // behind the current song in the default songs list.
            while (accumulatedSongsQueue.length > 0) {
                thisLevelData.songs.insert(
                    thisLevelData.songs.indexOf(songId),
                    accumulatedSongsQueue.shift()
                );
            }
        }
        // push all the remaining songs from the
        // queue to the end of the default songs list.
        while (accumulatedSongsQueue.length > 0) {
            thisLevelData.songs.push(accumulatedSongsQueue.shift());
        }

        // using this method, we can add songs to the
        // level's song list while keeping the intended
        // order of the songs in the list, and without
        // having to worry about adding songs that are
        // already in the list.

        // Note that it's your responsibility to make sure
        // the songs appear only in the variations/difficulties
        // you want them to appear in, because added songs
        // will appear for all the difficulties they have,
        // regardless of the variation or difficulty associated 
        // with the alt level data which added them. This is
        // especially important if you don't want your song 
        // to appear in the default variation, because the 
        // game normally forces you to have a default variation,
        // but you can still remove it's difficulties from your
        // song script's constructor.
    }


    /**
     * Get the list of songs in this level, as an array of IDs.
     * @return Array<String>
     */
    function getSongsFR(level:Level, difficulty:String):Array<String> {
        // gets the songs normally
        var songs = level.getSongs();
        if (songs == null) {return null;}
        // filter out songs that don't have
        // the provided difficulty
        return songs.filter(
            function(songId:String) {
                // if the song doesn't have the  
                // current difficulty, filter it out.
                var song = SongRegistry.instance.fetchEntry(songId);
                return song.getDifficulty(difficulty, null, song.variations) != null;
            }
        );

        // using this method, we can display
        // the maximum amount of songs possible
        // in the story menu state, while also making
        // PlayState not load songs that don't have
        // the current difficulty, which would have
        // caused an error which could have taken us
        // back to the main menu.
    }


    
    // I have to declare it here because
    // Hscript forgets it too quickly if I don't.
    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    /**
     * I'm using this array to track the difficulties I
     * return in getDifficultiesFR.
     */
    var difficultiesFR:Array<String> = [];

    /**
     * The list of difficulties the player can select from for this level.
     * @return The difficulty IDs.
     */
    function getDifficultiesFR(level:Level):Array<String> {
        // calibrates the difficulties array
        this.difficultiesFR = [];
        // declare the song variable
        var song = null;
        // iterate through the songs
        // included in the level
        for (songId in level.getSongs()) {
            // fetch the song object from the registry
            song = SongRegistry.instance.fetchEntry(songId);
            // if it doesn't exist,
            // continue to the next song
            if (song == null) {continue;}

            // iterate through the
            // difficulties of the song
            // (non-hidden difficulties)
            for (diff in song.listDifficulties(null, song.variations, true, false)) {
                // push the difficulty to the
                // difficulties array if it's not
                // already there
                ArrayTools.pushUnique(this.difficultiesFR, diff);
            }
        }
        // sort the difficulties array
        this.difficultiesFR.sort(this.sortingStoryDiffs);
        // return the final 
        // sorted difficulties array
        return this.difficultiesFR;

        // Using this method, we can display
        // the maximum amount of difficulties
        // available in the level in the story
        // menu state. getSongs will filter out
        // the songs that don't have the current
        // difficulty, so we don't have to worry
        // about that here.
    }

    /**
     * uses the default difficulty list to sort the difficulties
     * (this list gets modified by the variation injector in order
     * to implement the difficulty "rating" system, which sorts the
     * difficulties according to their "playData.ratings" numbers)
     * @param a a member of the sorted array
     * @param b another member of the sorted array
     * @return Int
     */
    function sortingStoryDiffs(a:String, b:String):Int {
        // Hscript doesn't want to use bind, so I made this...
        return SortUtil.defaultsThenAlphabetically(Constants.DEFAULT_DIFFICULTY_LIST, a, b);
    }


    var resultSongDisplay:Array<String> = [];

    /**
     * Get the list of songs in this level, as an array of names, for display on the menu.
     * @param difficulty The difficulty of the level being displayed
     * @return The display names of the songs in this level
     */
    function getSongDisplayNamesFR(level:Level, difficulty:String):Array<String> {
        resultSongDisplay = level.getSongDisplayNames(difficulty);
        trace(resultSongDisplay);
        var songList:Array<String> = level.getSongs();
        trace(songList);
        if (songList == null) {return resultSongDisplay;}
        var songNameList:Array<String> = songList.map(function(songId:String) {
            return Level.getSongDisplayName(songId, difficulty);
        });
        trace(songNameList);
        return resultSongDisplay.map(function(songName:String) {
            if (songName == 'Unknown') {return songName;}
            var index = songNameList.indexOf(songName);
            if (index != -1) {
                var song = SongRegistry.instance.fetchEntry(songList[index]);
                var vari = song.getFirstValidVariation(difficulty);
                if (vari == null) {return '';}
                return song._metadata.get(vari).songName;
            }
            return songName;
        }).filter(function(songName:String) {
            return songName != '';
        });
    }

    function updateTextFR():Void {
        if (this.storyMenu == null) {return;}
        this.storyMenu.tracklistText.text = 'TRACKS\n\n';
        this.storyMenu.tracklistText.text += this.getSongDisplayNamesFR(this.storyMenu.currentLevel,
            this.storyMenu.currentDifficultyId).join('\n');

        this.storyMenu.tracklistText.screenCenter(0x01);
        this.storyMenu.tracklistText.x -= FlxG.width * 0.35;

        var levelScore = Save.instance.getLevelScore(this.storyMenu.currentLevelId,
            this.storyMenu.currentDifficultyId);
        if (levelScore == null) {
            this.storyMenu.highScore = 0;
            return;
        }
        this.storyMenu.highScore = levelScore.score;
    }


    var difficultiesAltDataVari:Array<String> = [];
    var levelAltDataVari:Dynamic = null;

    function addLevelAltDataForVariation(levelId:String, variationId:String):Void {
        trace('[story-diffs]  -  Request received for alt data for level ('+levelId+') on variation ('+variationId+')');
        var path = Paths.json(BASE_PREFIX_LADP+VARIS_PREFIX_LADP+variationId+"/"+levelId);
        if (!Assets.exists(path)) {return;}
        difficultiesAltDataVari = [];
        for (diffIndex in 0...difficultiesToVariations[1].length) {
            if (difficultiesToVariations[1][diffIndex] == variationId &&
                !this.levelAltData[0].contains(difficultiesToVariations[0][diffIndex]+levelId))
            {
                difficultiesAltDataVari.push(difficultiesToVariations[0][diffIndex]);
            }
        }
        if (difficultiesAltDataVari.length == 0) {return;}

        levelAltDataVari = LevelRegistry.instance.parseEntryDataRaw(StringTools.trim(Assets.getText(path)), path);

        this.considerAddingSongs(LevelRegistry.instance.fetchEntry(levelId), levelAltDataVari.songs);

        for (diff in difficultiesAltDataVari) {
            this.levelAltData[0].push(diff+levelId);
            this.levelAltData[1].push(levelAltDataVari);
        }

        if (!this.hasAltData.contains(levelId)) {
            this.hasAltData.push(levelId);
        }

        trace('[story-diffs]  -  Successfully added alt data for level ('+levelId+') on variation ('+variationId+')');
    }

    function addLevelAltDataForDifficulty(levelId:String, difficultyId:String):Void {
        trace('[story-diffs]  -  Request received for alt data for level ('+levelId+') on difficulty ('+difficultyId+')');
        var path = Paths.json(BASE_PREFIX_LADP+DIFFS_PREFIX_LADP+difficultyId+"/"+levelId);
        if (!Assets.exists(path)) {return;}

        var levelData:Dynamic = LevelRegistry.instance.parseEntryDataRaw(StringTools.trim(Assets.getText(path)), path);

        this.considerAddingSongs(LevelRegistry.instance.fetchEntry(levelId), levelData.songs);

        this.levelAltData[0].push(difficultyId+levelId);
        this.levelAltData[1].push(levelData);

        if (!this.hasAltData.contains(levelId)) {
            this.hasAltData.push(levelId);
        }
        trace('[story-diffs]  -  Successfully added alt data for level ('+levelId+') on difficulty ('+difficultyId+')');
    }


    function setup():Void {
        if (this.finishedSetup) {return;}

        var levelIdList:Array<String> = [];

        // This is only used for reading
        // stuff and doesn't get modyfied.
        this.difficultiesToVariations = ModuleHandler.
            getModule("vari-injector").scriptGet("difficultiesToVariations");
        
        // Making alt level data for the
        // default variation is not recommended.
        // Please use the default level data instead.
        var allVariations:Array<String> = [];
        for (variationId in this.difficultiesToVariations[1]) {
            if (!allVariations.contains(variationId)) {
                allVariations.push(variationId);
            }
        }
        allVariations.remove("default");

        for (variationId in allVariations) {

            levelIdList = DataAssets.listDataFilesInPath(BASE_PREFIX_LADP+VARIS_PREFIX_LADP+variationId+"/", '.json').map(
                function(levelAltDataPath:String):String {
                    return levelAltDataPath.split('/')[0];
                }
            );

            for (levelId in levelIdList) {
                this.addLevelAltDataForVariation(levelId, variationId);
            }
        }

        var allDifficulties:Array<String> = this.difficultiesToVariations[0].copy();

        for (difficultyId in allDifficulties) {

            levelIdList = DataAssets.listDataFilesInPath(BASE_PREFIX_LADP+DIFFS_PREFIX_LADP+difficultyId+"/", '.json').map(
                function(levelAltDataPath:String):String {
                    return levelAltDataPath.split('/')[0];
                }
            );

            for (levelId in levelIdList) {
                this.addLevelAltDataForDifficulty(levelId, difficultyId);
            }
        }

        for (levelId in this.hasAltData) {
            this.resetDataToDefault(LevelRegistry.instance.fetchEntry(levelId));
        }

        trace('[story-diffs]  -  Setup completed successfully');

        this.finishedSetup = true;
    }

    public override function onCreate(event:ScriptEvent):Void {
        super.onCreate();
        setup();
    }


    public override function onStateChangeEnd(event:StateChangeScriptEvent):Void {
        // trace('called onStateChangeEnd');
        super.onStateChangeEnd();
        if (Std.isOfType(event.targetState, StoryMenuState)) {
            this.storyMenu = event.targetState;
            this.justEnteredStoryMenu = true;
            this.storyMenu.persistentUpdate = true;
            // trace('StoryDiffs ON');
            // trace(this.lastRememberedDifficulty);
            // trace(this.lastDifficultyList);
        } else if (this.storyMenu != null) {
            this.storyMenu = null;
            // trace('StoryDiffs OFF');
            // trace(this.lastRememberedDifficulty);
            // trace(this.lastDifficultyList);
        }
        setup();
    }

    public override function onUpdate(event:UpdateScriptEvent):Void {
        if (this.storyMenu == null) {return;}
        overrideCreationCall();
        if (!this.storyMenu.exitingMenu) {
            if (!this.storyMenu.selectedLevel) {
                boundDifficulty();
                forceDifficultyChange();
                determineArrowVisibility();
                determineScrollBehavior();
                if (this.storyMenu.controls.ACCEPT) {
                    this.dispatchEvent(new ScriptEvent(this.CONFIRMED));
                }
            } else {
                var tmr = FlxTimer.globalManager._timers[FlxTimer.globalManager._timers.length-1];
                tmr.onComplete = function() {
                    FlxTransitionableState.skipNextTransIn = false;
                    FlxTransitionableState.skipNextTransOut = false;

                    PlayStatePlaylist.playlistSongIds = this.getSongsFR(
                        LevelRegistry.instance.fetchEntry(PlayStatePlaylist.campaignId),
                        PlayStatePlaylist.campaignDifficulty
                    );

                    var targetSong = SongRegistry.instance.fetchEntry(PlayStatePlaylist.playlistSongIds.shift());

                    var targetVariation:String = targetSong.getFirstValidVariation(PlayStatePlaylist.campaignDifficulty);

                    var targetInstId:String = targetSong.getDifficulty(PlayStatePlaylist.campaignDifficulty, targetVariation).characters.instrumental;

                    LoadingState.loadPlayState({
                        targetSong: targetSong,
                        targetDifficulty: PlayStatePlaylist.campaignDifficulty,
                        targetVariation: targetVariation,
                        targetInstrumental: targetInstId
                    }, true);
                };
                this.dispatchEvent(new ScriptEvent(this.CONFIRMED));
                this.storyMenu = null;
            }
        } else {
            this.dispatchEvent(new ScriptEvent(this.EXITED));
            this.storyMenu = null;
        }
    }

    function overrideCreationCall():Void {
        if (!this.justEnteredStoryMenu) {return;}
        this.storyMenu.currentDifficultyId = this.lastRememberedDifficulty;
        StoryMenuState.rememberedDifficulty = this.storyMenu.currentDifficultyId;
        determineArrowVisibility();
        this.storyMenu.buildDifficultySprite();
        this.storyMenu.funnyMusicThing();
        this.updateTextFR();
        this.storyMenu.refresh();
        this.dispatchEvent(new ScriptEvent(this.ENTERED));
        this.justEnteredStoryMenu = false;
    }

    function boundDifficulty():Void {
        if (this.storyMenu ==  null) {return;}

        var curDifficultyList = this.getDifficultiesFR(this.storyMenu.currentLevel);
        if (ArrayTools.isEqualUnordered(curDifficultyList, this.lastDifficultyList)) {return;}
        trace(curDifficultyList);

        var newIndex:Int = curDifficultyList.indexOf(this.lastRememberedDifficulty);
        if (newIndex == -1) {
            newIndex = this.lastDifficultyList.indexOf(this.lastRememberedDifficulty);
            if (newIndex == -1) {newIndex = 0;}
            newIndex = (newIndex / (this.lastDifficultyList.length-1)) * (curDifficultyList.length-1);
        }

        this.lastDifficultyList = curDifficultyList;
        this.storyMenu.currentDifficultyId = this.lastDifficultyList[newIndex];
        StoryMenuState.rememberedDifficulty = this.storyMenu.currentDifficultyId;
        this.lastRememberedDifficulty = StoryMenuState.rememberedDifficulty;
        // trace("difficulty bound successful");
    }

    function forceDifficultyChange():Void {
        if (this.storyMenu ==  null) {return;}

        var change:Int = 0;
        if (this.storyMenu.controls.UI_RIGHT_P) {change++;}
        if (this.storyMenu.controls.UI_LEFT_P) {change--;}
        if (change == 0) {return;}

        var currentIndex:Int = this.lastDifficultyList.indexOf(this.lastRememberedDifficulty) + change;

        // Wrap around
        if (currentIndex < 0) {currentIndex = this.lastDifficultyList.length - 1;}
        if (currentIndex >= this.lastDifficultyList.length) {currentIndex = 0;}

        this.storyMenu.currentDifficultyId = this.lastDifficultyList[currentIndex];
        StoryMenuState.rememberedDifficulty = this.storyMenu.currentDifficultyId;
        this.lastRememberedDifficulty = StoryMenuState.rememberedDifficulty;
        // trace("forced difficulty change successful");
    }

    function determineArrowVisibility():Void {
        if (this.storyMenu ==  null) {return;}
        if (this.lastDifficultyList.length <= 1) {
            this.storyMenu.leftDifficultyArrow.visible = false;
            this.storyMenu.rightDifficultyArrow.visible = false;
            return;
        }
        this.storyMenu.leftDifficultyArrow.visible = true;
        this.storyMenu.rightDifficultyArrow.visible = true;
    }

    // PLEASE DON'T MODIFY THESE VARIABLES!!!
    var prvData:Dynamic = null;
    var prvColor:Int = 0x0;

    function determineScrollBehavior():Void {
        if (this.storyMenu ==  null) {return;}
        if (this.storyMenu.controls.UI_RIGHT_P ||
            this.storyMenu.controls.UI_LEFT_P ||
            this.storyMenu.controls.UI_UP_P ||
            this.storyMenu.controls.UI_DOWN_P)
        {
            this.storyMenu.buildDifficultySprite();
            FunkinSound.stopAllAudio(false);
            FunkinSound.playOnce(Paths.sound('scrollMenu'), 0.4);
            this.storyMenu.funnyMusicThing();

            this.prvData = this.storyMenu.currentLevel._data;
            this.prvColor = this.storyMenu.currentLevel.getBackgroundColor();
            if (this.hasAltData.contains(this.storyMenu.currentLevelId)) {
                var loadedNewData:Bool = false;
                loadedNewData = this.reloadLevelData();
                if (!loadedNewData) {
                    this.resetDataToDefault(this.storyMenu.currentLevel);
                }
            }


            if (this.lastRememberedLevelId != this.storyMenu.currentLevelId) {
                var prvLevel:Level = LevelRegistry.instance.fetchEntry(this.lastRememberedLevelId);
                prvData = prvLevel._data;
                prvColor = prvLevel.getBackgroundColor();
            }
            this.forceUpdateBackground();

            if (prvData != this.storyMenu.currentLevel._data) {
                this.storyMenu.updateProps();
                this.storyMenu.currentLevelTitle.title.loadGraphic(
                    Paths.image(this.storyMenu.currentLevel._data.titleAsset)
                );
            }
            this.updateTextFR();
            this.storyMenu.refresh();
            trace('difficulty sprite rebuild successful \n(difficultyId: "'+this.lastRememberedDifficulty+'")');
            this.lastRememberedLevelId = this.storyMenu.currentLevelId;
            
            this.dispatchEvent(new ScriptEvent(this.SCROLLED));
        }
    }

    function reloadLevelData():Bool {
        if (this.storyMenu ==  null) {return;}
        var newData:Dynamic = null;
        if (this.levelAltData[0].contains(this.storyMenu.currentDifficultyId+this.storyMenu.currentLevelId)) {
            newData = this.levelAltData[1][
                this.levelAltData[0].indexOf(this.storyMenu.currentDifficultyId+this.storyMenu.currentLevelId)
            ];
        }
        if (newData != null) {
            this.reloadData(this.storyMenu.currentLevel, newData);
            return true;
        }
        return false;
    }

    function forceUpdateBackground():Void {
        if (this.storyMenu ==  null) {return;}
        // use a custom Background transition, which is
        // the same, but for switching between difficulties
        var newColor:Int = this.storyMenu.currentLevel.getBackgroundColor();

        if (this.prvData.background.charAt(0) == '#' && this.storyMenu.currentLevel._data.background.charAt(0) == '#') {
            if (this.prvColor != newColor) {
                // Both the previous and current level were simple backgrounds.
                // Fade between colors directly, rather than fading one background out and another in.
                // cancels potential tween in progress, and tweens from there
                FlxTween.cancelTweensOf(this.storyMenu.levelBackground);
                FlxTween.color(this.storyMenu.levelBackground, 0.9, this.storyMenu.levelBackground.color,
                    newColor, {ease: FlxEase.quartOut});
            } else {
                // Both the previous and current level were simple backgrounds.
                // No need to fade between colors, just update the color, because
                // the previous call to updateBackground() from the source code
                // might relay on data that changed already (in short, it's a bug fix)
                FlxTween.cancelTweensOf(this.storyMenu.levelBackground);
                this.storyMenu.levelBackground.color = newColor;
            }
        } else {
            // Either the previous or current level has a complex background.
            // We need to fade the old background out and the new one in.

            // Reference the old background and fade it out.
            var oldBackground:FlxSprite = this.storyMenu.levelBackground;
            FlxTween.tween(oldBackground, {alpha: 0.0}, 0.6, {
                ease: FlxEase.linear,
                onComplete: function(_) {
                    this.storyMenu.remove(oldBackground);
                }
            });

            // Build a new background and fade it in.
            this.storyMenu.levelBackground = this.storyMenu.currentLevel.buildBackground();
            this.storyMenu.levelBackground.x = 0;
            this.storyMenu.levelBackground.y = 56;
            this.storyMenu.levelBackground.alpha = 0.0; // Hidden to start.
            this.storyMenu.levelBackground.zIndex = 100;
            this.storyMenu.add(levelBackground);

            FlxTween.tween(this.storyMenu.levelBackground, {alpha: 1.0}, 0.6, {
                ease: FlxEase.linear
            });
        }
    }

    /**
     * Handle difficulty changes from pause menu when in story mode
     */
    public override function onSongRetry(event:ScriptEvent):Void {
        super.onSongRetry(event);

        if (!PlayStatePlaylist.isStoryMode ||
            PlayState.instance.currentDifficulty == this.lastRememberedDifficulty)
        {return;}
        
        this.lastRememberedDifficulty = PlayState.instance.currentDifficulty;
        
        if (PlayStatePlaylist.playlistSongIds.length < 1) {return;}

        PlayStatePlaylist.playlistSongIds = this.getSongsFR(LevelRegistry.instance.fetchEntry(this.lastRememberedLevelId),
            PlayState.instance.currentDifficulty);
        PlayStatePlaylist.playlistSongIds.splice(0,PlayStatePlaylist.
            playlistSongIds.indexOf(PlayState.instance.currentSong.id));
    }
}