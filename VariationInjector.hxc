import haxe.ds.ArraySort;

import funkin.modding.module.Module;

import funkin.save.Save;

import funkin.play.song.Song;
import funkin.play.song.ScriptedSong;
import funkin.play.song.SongDifficulty;

import funkin.modding.PolymodErrorHandler;

import funkin.ui.freeplay.FreeplayState;

import funkin.data.song.SongRegistry;
import funkin.data.song.SongMetadata;

import funkin.util.Constants;
import funkin.util.DataAssets;
import funkin.util.tools.ArrayTools;

/**
 * In order for this to work, the base
 * song's script needs to use the
 * template on docs/templates/SongScriptTemplate.hxc
 */
class VariationInjector extends Module {

    public function new()
    {
        super('vari-injector');
        this.priority = 0;
    }
    
    public var difficultySorting:Array<Array<String>> = [
        ["easy","normal","hard","erect","nightmare"],
        ["1","3","5","7","9"]
    ];

    // Difficulties and variations MUST have
    // a One-to-many relationship, meaning that
    // a variation can have many difficulties,
    // but a difficulty can have ONE variation.
    // This rule applies to all difficulties, except
    // for hidden ones (like "picospeaker") which exist
    // only in the chart files, and are not shown in game
    public var difficultiesToVariations:Array<Array<String>> = [
        ["easy","normal","hard","erect","nightmare"],
        ["default","default","default","erect","erect"]
    ];


    var variInjectPathPrefix:String = "UD/injections/variations/";

    var finishedSetup:Bool = false;

    // I'm using these variables to sort and validate the difficulties.
    // I'm declaring them here because I need to access them
    // from a bigger scope, which I apparantly can't get on
    // the Hscript stack, which is extremely bizarre.
    // it literally just forgets some of the variables
    // I declared if I don't declare them as attributes here.
    var variSORT:String = "";
    var ratingsSORT:Map<String, Int> = null;
    var difficultiesSORT:Array<String> = [];
    var forRemovalDiffSORT:Array<String> = [];
    var forRemovalVariSORT:Array<String> = [];
    var songSORT:Song = null;

    function sortDifficulties(a:String, b:String):Int {
        var numA:Int = Std.parseInt(this.difficultySorting[1][this.difficultySorting[0].indexOf(a)]);
        var numB:Int = Std.parseInt(this.difficultySorting[1][this.difficultySorting[0].indexOf(b)]);
        if (numA < numB) {
            return -1;
        }
        if (numA > numB) {
            return 1;
        }
        return 0;
    }

    function injectVariationToSong(variId:String, songId:String):Void {
        var entry = SongRegistry.instance.fetchEntry(songId);
        if (entry == null) {return;}
        if (entry.variations.contains(variId)) {return;}
        var songClassName:String = SongRegistry.instance.getScriptedEntryClassName(songId);
        if (songClassName == null) {
            trace('[vari-injector]  -  Failed to inject variations to song,'+
                ' because it didn\'t have a scripted class ('+songId+' , '+variId+')');
            return;
        }
        if (entry.scriptCall('injectVariation', [variId])) {
            trace('[vari-injector]  -  Successfully injected variation to song '+
                '('+variId+' => '+songId+')');
            return;
        }
        trace('[vari-injector]  -  Failed to inject variations to song ('+songClassName+' , '+variId+')');
    }

    function setup():Void {
        if (finishedSetup) {return;}

        // gets all the variation injection files
        var variIdList:Array<String> = DataAssets.listDataFilesInPath(variInjectPathPrefix, '.json').map(
            function(variInjectPath:String):String {
                return variInjectPath.split('/')[0];
            }
        );

        // Create a new parser for the variation injection data,
        // which is a list of all songs that need to have a certaion
        // variation injected.
        var parser = new json2object.JsonParser<Array<String>>();
        parser.ignoreUnknownVariables = true;
        
        // For each variation injection file,
        // parse it and inject the variation to
        // each song that needs it.
        for (variId in variIdList) {
            var path:String = variInjectPathPrefix+variId+'.json';
            parser.fromJson(StringTools.trim(Assets.getText(path)), path);
            for (error in parser.errors)
            {
                DataError.printError(error);
            }
            if (parser.errors.length > 0)
            {
                trace('[vari-injector]  FAILED to parse variation injection data: '+variId);
                continue;
            }
            for (songId in ArrayTools.unique(parser.value)) {
                this.injectVariationToSong(variId, songId);
            }
        }
        trace("[vari-injector]  -  Finished injecting variations");


        Constants.DEFAULT_DIFFICULTY_LIST = ["easy","normal","hard","erect","nightmare"];

        for (songIdSORT in SongRegistry.instance.listBaseGameSongIds().concat(SongRegistry.instance.listModdedSongIds())) {
            songSORT = SongRegistry.instance.fetchEntry(songIdSORT);
            songSORT.difficulties.clear();
            songSORT.populateDifficulties();
            forRemovalVariSORT = [];
            for (vari in songSORT.variations) {
                variSORT = vari;
                ratingsSORT = songSORT._metadata.get(variSORT).playData.ratings;
                difficultiesSORT = songSORT._metadata.get(variSORT).playData.difficulties;
                forRemovalDiffSORT = [];
                for (diff in difficultiesSORT) {
                    if (difficultiesToVariations[0].contains(diff)) {
                        if (difficultiesToVariations[1][difficultiesToVariations[0].indexOf(diff)] != variSORT) {
                            var differentVari = difficultiesToVariations[1][difficultiesToVariations[0].indexOf(diff)];
                            PolymodErrorHandler.showAlert("Variation-Difficulty Relationship Error", "Tried to add"+
                                " a difficulty ("+diff+") to a variation ("+variSORT+"), but the difficulty already had"+
                                " a different variation assigned to it ("+differentVari+") (on song: "+songSORT.id+").");
                            forRemovalDiffSORT.push(diff);
                            continue;
                        }
                    } else {
                        difficultiesToVariations[0].push(diff);
                        difficultiesToVariations[1].push(variSORT);
                    }
                    if (!Constants.DEFAULT_DIFFICULTY_LIST.contains(diff) && ratingsSORT.exists(diff)) {
                        Constants.DEFAULT_DIFFICULTY_LIST.push(diff);
                        difficultySorting[0].push(diff);
                        difficultySorting[1].push(ratingsSORT.get(diff));
                        ArraySort.sort(Constants.DEFAULT_DIFFICULTY_LIST, sortDifficulties);
                    }
                }
                for (diff in forRemovalDiffSORT) {
                    difficultiesSORT.remove(diff);
                    var variationSuffix:String = (variSORT != Constants.DEFAULT_VARIATION) ? '-'+variSORT : '';
                    songSORT.difficulties.remove(diff+variationSuffix);
                }
                if (difficultiesSORT.length == 0) {
                    forRemovalVariSORT.push(variSORT);
                }
            }
            for (vari in forRemovalVariSORT) {
                songSORT.variations.remove(vari);
                songSORT._metadata.remove(vari);
            }
        }

        finishedSetup = true;
    }


    public override function onCreate(event:ScriptEvent):Void {
        this.setup();
        super.onCreate();
    }

    public override function onStateChangeEnd(event:StateChangeScriptEvent):Void {
        this.setup();
        super.onStateChangeEnd();
    }


    var freeplayState:FreeplayState = null;

    public override function onSubStateOpenEnd(event:SubStateScriptEvent):Void {
        if (Std.isOfType(event.targetState, FreeplayState)) {
            freeplayState = event.targetState;
        }
        super.onSubStateOpenEnd();
    }

    public override function onUpdate(event:UpdateScriptEvent):Void {
        if (freeplayState != null) {
            ArraySort.sort(freeplayState.diffIdsTotal,sortDifficulties);
            freeplayState = null;
        }
        super.onUpdate();
    }
}