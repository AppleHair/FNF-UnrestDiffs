// TODO: Add more comments to this file
import Array;
import flixel.text.FlxText;
import funkin.data.DataError;
import funkin.data.song.SongRegistry;
import funkin.modding.module.Module;
import funkin.modding.PolymodErrorHandler;
import funkin.Paths;
import funkin.play.PauseSubState;
import funkin.play.PlayState;
import funkin.play.song.Song;
import funkin.ui.AtlasText;
import funkin.ui.freeplay.FreeplayState;
import funkin.util.assets.DataAssets;
import funkin.util.Constants;
import funkin.util.tools.ArrayTools;
import haxe.ds.ArraySort;
import haxe.Json;
import openfl.utils.Assets;
import String;
import StringTools;

/**
 * In order for this to work, the base
 * song's script needs to use the
 * template on docs/templates/SongScriptTemplate.hxc
 */
class VariationInjector extends Module {

    function new()
    {
        super('vari-injector', 0);
    }

    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    var VART_INJECT_PATH_PREFIX:String = "UD/injections/variations/";

    // Difficulties and variations MUST have
    // a One-to-many relationship, meaning that
    // a variation can have many difficulties,
    // but a difficulty can have ONE variation.
    // This rule applies to all difficulties, except
    // for hidden ones (like "picospeaker") which exist
    // only in the chart files, and are not shown in game
    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    var difficultiesToVariations:Array<Array<String>> = [
        ["easy","normal","hard","erect","nightmare"],
        ["default","default","default","erect","erect"]
    ];
    
    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    var difficultySorting:Array<Array<String>> = [
        ["easy","normal","hard","erect","nightmare"],
        ["1","3","5","7","9"]
    ];

    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    /**
     * Used for tracking setup completion.
     */
    var finishedSetup:Bool = false;

    
    // I have to declare them here because
    // Hscript forgets them too quickly if I don't.
    // I'm using these variables to sort and validate
    // the difficulties on setup.
    // PLEASE DON'T MODIFY THESE VARIABLES!!!
    var variSORT:String = "";
    var ratingsSORT:Map<String, Int> = null;
    var difficultiesSORT:Array<String> = [];
    var forRemovalDiffSORT:Array<String> = [];
    var forRemovalVariSORT:Array<String> = [];
    var songSORT:Song = null;

    function sortDifficulties(a:String, b:String):Int {
        var numA:Int = Std.parseInt(this.difficultySorting[1][this.difficultySorting[0].indexOf(a)]);
        var numB:Int = Std.parseInt(this.difficultySorting[1][this.difficultySorting[0].indexOf(b)]);
        if (numA < numB) {
            return -1;
        }
        if (numA > numB) {
            return 1;
        }
        return 0;
    }

    function injectVariationToSong(variId:String, songId:String):Void {
        var entry = SongRegistry.instance.fetchEntry(songId);
        if (entry == null) {return;}
        if (entry.variations.contains(variId)) {return;}
        var songClassName:String = SongRegistry.instance.getScriptedEntryClassName(songId);
        if (songClassName == null) {
            trace('[vari-injector]  -  Failed to inject variations to song,'+
                ' because it didn\'t have a scripted class ('+songId+' , '+variId+')');
            return;
        }
        if (entry.scriptCall('injectVariation', [variId])) {
            trace('[vari-injector]  -  Successfully injected variation to song '+
                '('+variId+' => '+songId+')');
            return;
        }
        trace('[vari-injector]  -  Failed to inject variations to song ('+songClassName+' , '+variId+')');
    }
    
    // I have to declare it here because
    // Hscript forgets it too quickly if I don't.
    // Used for error handling on setup.
    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    var variIdERRORCHECK:String = "";

    function setup():Void {
        if (this.finishedSetup) {return;}

        // gets all the variation injection files.
        var variIdList:Array<String> = DataAssets.listDataFilesInPath(VART_INJECT_PATH_PREFIX, '.json').map(
            function(variInjectPath:String):String {
                return variInjectPath.split('/')[0];
            }
        );
        // if a file is named "default.json", it will be ignored,
        // because you can't inject the default variation to a song,
        // it'll always be there.
        variIdList.remove("default");
        
        // For each variation injection file,
        // parse it and inject the variation to
        // each song that needs it.
        for (variId in variIdList) {
            var path:String = Paths.json(VART_INJECT_PATH_PREFIX+variId);
            var result = Json.parse(StringTools.trim(Assets.getText(path)));
            var valid = Std.isOfType(result.songIds, Array);
            valid = valid && result.songIds.length > 0;
            if (!valid) {
                PolymodErrorHandler.showAlert("Variation Injection Error",
                    "Failed to parse variation injection file: "+variId+
                    "\nsongIds value was either not an array or was empty.");
                continue;
            }
            variIdERRORCHECK = variId;
            for (songId in ArrayTools.unique(result.songIds)) {
                var validSong = Std.isOfType(songId, String);
                if (!validSong) {
                    PolymodErrorHandler.showAlert("Variation Injection Error", "A song id wasn't a string in"+
                        "\nvariation injection file: "+variIdERRORCHECK+"\nFailed to parse song id value: "+songId);
                    break;
                }
                this.injectVariationToSong(variId, songId);
            }
        }
        trace("[vari-injector]  -  Finished injecting variations");

        Constants.DEFAULT_DIFFICULTY_LIST = ["easy","normal","hard","erect","nightmare"];

        for (songIdSORT in SongRegistry.instance.listBaseGameSongIds().concat(SongRegistry.instance.listModdedSongIds())) {
            songSORT = SongRegistry.instance.fetchEntry(songIdSORT);
            songSORT.difficulties.clear();
            songSORT.populateDifficulties();
            forRemovalVariSORT = [];
            for (vari in songSORT.variations) {
                variSORT = vari;
                ratingsSORT = songSORT._metadata.get(variSORT).playData.ratings;
                difficultiesSORT = songSORT._metadata.get(variSORT).playData.difficulties;
                forRemovalDiffSORT = [];
                for (diff in difficultiesSORT) {
                    if (difficultiesToVariations[0].contains(diff)) {
                        if (difficultiesToVariations[1][difficultiesToVariations[0].indexOf(diff)] != variSORT) {
                            var differentVari = difficultiesToVariations[1][difficultiesToVariations[0].indexOf(diff)];
                            PolymodErrorHandler.showAlert("Variation-Difficulty Relationship Error", "Tried to add"+
                                " a difficulty ("+diff+") to a variation ("+variSORT+"), but the difficulty already had"+
                                " a different variation assigned to it ("+differentVari+") (on song: "+songSORT.id+").");
                            forRemovalDiffSORT.push(diff);
                            continue;
                        }
                    } else {
                        difficultiesToVariations[0].push(diff);
                        difficultiesToVariations[1].push(variSORT);
                    }
                    if (!Constants.DEFAULT_DIFFICULTY_LIST.contains(diff) && ratingsSORT.exists(diff)) {
                        Constants.DEFAULT_DIFFICULTY_LIST.push(diff);
                        difficultySorting[0].push(diff);
                        difficultySorting[1].push(ratingsSORT.get(diff));
                        ArraySort.sort(Constants.DEFAULT_DIFFICULTY_LIST, sortDifficulties);
                    }
                }
                for (diff in forRemovalDiffSORT) {
                    difficultiesSORT.remove(diff);
                    var variationSuffix:String = (variSORT != Constants.DEFAULT_VARIATION) ? '-'+variSORT : '';
                    songSORT.difficulties.remove(diff+variationSuffix);
                }
                if (difficultiesSORT.length == 0) {
                    forRemovalVariSORT.push(variSORT);
                }
            }
            for (vari in forRemovalVariSORT) {
                songSORT.variations.remove(vari);
                songSORT._metadata.remove(vari);
            }
        }

        trace("[vari-injector]  -  Finished setting up variations");

        this.finishedSetup = true;
    }


    public override function onCreate(event:ScriptEvent):Void {
        super.onCreate();
        setup();
    }

    public override function onStateChangeEnd(event:StateChangeScriptEvent):Void {
        super.onStateChangeEnd();
        setup();
    }

    var freeplayState:FreeplayState = null;

    public override function onSubStateOpenEnd(event:SubStateScriptEvent):Void {
        super.onSubStateOpenEnd();
        if (Std.isOfType(event.targetState, FreeplayState)) {
            freeplayState = event.targetState;
        }
    }

    var capturedDiscordRPC:Bool = false;
    var tmpDiff:String = "";

    public override function onUpdate(event:UpdateScriptEvent):Void {
        super.onUpdate();
        if (freeplayState != null) {
            ArraySort.sort(freeplayState.diffIdsTotal,sortDifficulties);
            freeplayState = null;
        }
        
        if (PlayState.instance == null) {
            capturedDiscordRPC = false;
            return;
        }
        if (capturedDiscordRPC && !PlayState.instance.needsReset) {return;}

        tmpDiff = PlayState.instance.currentDifficulty;
        PlayState.instance.currentDifficulty = this.
            trimDifficultyName(PlayState.instance.currentDifficulty,PlayState.instance.currentVariation,false);
        PlayState.instance.initDiscord();
        PlayState.instance.currentDifficulty = tmpDiff;

        capturedDiscordRPC = true;
    }

    /**
     * Converts a string to title case. For example, "hello world" becomes "Hello World".
     *
     * @param value The string to convert.
     * @return The converted string.
     */
    function toTitleCase(value:String):String {
        var words:Array<String> = value.split(' ');
        var result:String = '';
        for (i in 0...words.length) {
            var word:String = words[i];
            result += word.charAt(0).toUpperCase() + word.substr(1).toLowerCase();
            if (i < words.length - 1) {
                result += ' ';
            }
        }
        return result;
    }

    /**
     * Strip a given prefix from a string.
     * @param value The string to strip.
     * @param prefix The prefix to strip. If the prefix isn't found, the original string is returned.
     * @return The stripped string.
     */
    function stripPrefix(value:String, prefix:String):String {
        if (StringTools.startsWith(value,prefix)) {
            return value.substr(prefix.length);
        }
        return value;
    }

    function trimDifficultyName(diff:String, vari:String, ?title:Bool = true):String {
        var result = stripPrefix(diff, vari);
        if (diff.length <= vari.length) {result = diff;}
        return title ? toTitleCase(result) : result;
    }

    function pauseMetadataDifficultyNameReplacer(entry:FlxText):Void {
        if (PlayState.instance == null) {return;}
        if (!StringTools.startsWith(entry.text,"Difficulty: ")) {return;}

        entry.text = "Difficulty: "+this.trimDifficultyName(
            PlayState.instance.currentDifficulty,
            PlayState.instance.currentVariation
        );
    }

    var pauseSubstate:PauseSubState = null;

    function pauseDifficultyChangeListNameReplacer(entry:AtlasText):Void {
        if (PlayState.instance == null) {return;}
        if (this.pauseSubstate == null) {return;}
        if (this.pauseSubstate.currentMenuEntries == null) {return;}

        var entriesLen = this.pauseSubstate.currentMenuEntries.length;
        if (this.pauseSubstate.currentMenuEntries[entriesLen-1].text != 'Back') {return;}

        var diffList = PlayState.instance.currentSong.
            listDifficulties(PlayState.instance.currentVariation, true);

        var index = this.pauseSubstate.menuEntryText.group.members.indexOf(entry);
        if (index == -1 || index >= diffList.length) {return;}

        entry.text = this.trimDifficultyName(diffList[index],PlayState.instance.currentVariation,false);
    }

    function pauseDifficultyNameReplacer(maybeSomething):Void {
        if (this.pauseSubstate == null) {return;}

        if (this.pauseSubstate.metadata == maybeSomething) {
            this.pauseSubstate.metadata.group.memberAdded.
                add(this.pauseMetadataDifficultyNameReplacer);
        }

        if (this.pauseSubstate.menuEntryText != maybeSomething) {return;}

        this.pauseSubstate.menuEntryText.group.memberAdded.
            add(this.pauseDifficultyChangeListNameReplacer);
    }

    public override function onSubStateOpenBegin(event:SubStateScriptEvent):Void {
        super.onSubStateOpenBegin(event);
        if (Std.isOfType(event.targetState, PauseSubState)) {
            this.pauseSubstate = event.targetState;
            this.pauseSubstate.memberAdded.add(this.pauseDifficultyNameReplacer);
        }
    }
}