// TODO: Add more comments to this file
import funkin.data.song.SongRegistry;
import funkin.modding.module.Module;
import funkin.modding.PolymodErrorHandler;
import funkin.play.song.Song;
import funkin.ui.freeplay.FreeplayState;
import funkin.util.Constants;
import funkin.util.DataAssets;
import funkin.util.tools.ArrayTools;
import haxe.ds.ArraySort;

/**
 * In order for this to work, the base
 * song's script needs to use the
 * template on docs/templates/SongScriptTemplate.hxc
 */
class VariationInjector extends Module {

    function new()
    {
        super('vari-injector', 0);
    }

    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    var _VART_INJECT_PATH_PREFIX:String = "UD/injections/variations/";

    // Difficulties and variations MUST have
    // a One-to-many relationship, meaning that
    // a variation can have many difficulties,
    // but a difficulty can have ONE variation.
    // This rule applies to all difficulties, except
    // for hidden ones (like "picospeaker") which exist
    // only in the chart files, and are not shown in game
    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    var _difficultiesToVariations:Array<Array<String>> = [
        ["easy","normal","hard","erect","nightmare"],
        ["default","default","default","erect","erect"]
    ];
    
    public var difficultiesToVariations(get, never):Array<Array<String>>;
    function get_difficultiesToVariations():Array<Array<String>> {
        return ArrayTools.deepClone(_difficultiesToVariations);
    }
    
    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    var _difficultySorting:Array<Array<String>> = [
        ["easy","normal","hard","erect","nightmare"],
        ["1","3","5","7","9"]
    ];

    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    /**
     * Used for tracking setup completion.
     */
    var _finishedSetup:Bool = false;

    
    // I have to declare them here because
    // Hscript forgets them too quickly if I don't.
    // I'm using these variables to sort and validate
    // the difficulties on setup.
    // PLEASE DON'T MODIFY THESE VARIABLES!!!
    var _variSORT:String = "";
    var _ratingsSORT:Map<String, Int> = null;
    var _difficultiesSORT:Array<String> = [];
    var _forRemovalDiffSORT:Array<String> = [];
    var _forRemovalVariSORT:Array<String> = [];
    var _songSORT:Song = null;

    function sortDifficulties(a:String, b:String):Int {
        var numA:Int = Std.parseInt(this._difficultySorting[1][this._difficultySorting[0].indexOf(a)]);
        var numB:Int = Std.parseInt(this._difficultySorting[1][this._difficultySorting[0].indexOf(b)]);
        if (numA < numB) {
            return -1;
        }
        if (numA > numB) {
            return 1;
        }
        return 0;
    }

    function injectVariationToSong(variId:String, songId:String):Void {
        var entry = SongRegistry.instance.fetchEntry(songId);
        if (entry == null) {return;}
        if (entry.variations.contains(variId)) {return;}
        var songClassName:String = SongRegistry.instance.getScriptedEntryClassName(songId);
        if (songClassName == null) {
            trace('[vari-injector]  -  Failed to inject variations to song,'+
                ' because it didn\'t have a scripted class ('+songId+' , '+variId+')');
            return;
        }
        if (entry.scriptCall('injectVariation', [variId])) {
            trace('[vari-injector]  -  Successfully injected variation to song '+
                '('+variId+' => '+songId+')');
            return;
        }
        trace('[vari-injector]  -  Failed to inject variations to song ('+songClassName+' , '+variId+')');
    }

    function setup():Void {
        if (_finishedSetup) {return;}

        // gets all the variation injection files
        var variIdList:Array<String> = DataAssets.listDataFilesInPath(_VART_INJECT_PATH_PREFIX, '.json').map(
            function(variInjectPath:String):String {
                return variInjectPath.split('/')[0];
            }
        );

        // Create a new parser for the variation injection data,
        // which is a list of all songs that need to have a certaion
        // variation injected.
        var parser = new json2object.JsonParser<Array<String>>();
        parser.ignoreUnknownVariables = true;
        
        // For each variation injection file,
        // parse it and inject the variation to
        // each song that needs it.
        for (variId in variIdList) {
            var path:String = _VART_INJECT_PATH_PREFIX+variId+'.json';
            parser.fromJson(StringTools.trim(Assets.getText(path)), path);
            for (error in parser.errors)
            {
                DataError.printError(error);
            }
            if (parser.errors.length > 0)
            {
                trace('[vari-injector]  FAILED to parse variation injection data: '+variId);
                continue;
            }
            for (songId in ArrayTools.unique(parser.value)) {
                this.injectVariationToSong(variId, songId);
            }
        }
        trace("[vari-injector]  -  Finished injecting variations");


        Constants.DEFAULT_DIFFICULTY_LIST = ["easy","normal","hard","erect","nightmare"];

        for (songIdSORT in SongRegistry.instance.listBaseGameSongIds().concat(SongRegistry.instance.listModdedSongIds())) {
            _songSORT = SongRegistry.instance.fetchEntry(songIdSORT);
            _songSORT.difficulties.clear();
            _songSORT.populateDifficulties();
            _forRemovalVariSORT = [];
            for (vari in _songSORT.variations) {
                _variSORT = vari;
                _ratingsSORT = _songSORT._metadata.get(_variSORT).playData.ratings;
                _difficultiesSORT = _songSORT._metadata.get(_variSORT).playData.difficulties;
                _forRemovalDiffSORT = [];
                for (diff in _difficultiesSORT) {
                    if (_difficultiesToVariations[0].contains(diff)) {
                        if (_difficultiesToVariations[1][_difficultiesToVariations[0].indexOf(diff)] != _variSORT) {
                            var differentVari = _difficultiesToVariations[1][_difficultiesToVariations[0].indexOf(diff)];
                            PolymodErrorHandler.showAlert("Variation-Difficulty Relationship Error", "Tried to add"+
                                " a difficulty ("+diff+") to a variation ("+_variSORT+"), but the difficulty already had"+
                                " a different variation assigned to it ("+differentVari+") (on song: "+_songSORT.id+").");
                            _forRemovalDiffSORT.push(diff);
                            continue;
                        }
                    } else {
                        _difficultiesToVariations[0].push(diff);
                        _difficultiesToVariations[1].push(_variSORT);
                    }
                    if (!Constants.DEFAULT_DIFFICULTY_LIST.contains(diff) && _ratingsSORT.exists(diff)) {
                        Constants.DEFAULT_DIFFICULTY_LIST.push(diff);
                        _difficultySorting[0].push(diff);
                        _difficultySorting[1].push(_ratingsSORT.get(diff));
                        ArraySort.sort(Constants.DEFAULT_DIFFICULTY_LIST, sortDifficulties);
                    }
                }
                for (diff in _forRemovalDiffSORT) {
                    _difficultiesSORT.remove(diff);
                    var variationSuffix:String = (_variSORT != Constants.DEFAULT_VARIATION) ? '-'+_variSORT : '';
                    _songSORT.difficulties.remove(diff+variationSuffix);
                }
                if (_difficultiesSORT.length == 0) {
                    _forRemovalVariSORT.push(_variSORT);
                }
            }
            for (vari in _forRemovalVariSORT) {
                _songSORT.variations.remove(vari);
                _songSORT._metadata.remove(vari);
            }
        }

        _finishedSetup = true;
    }


    public override function onCreate(event:ScriptEvent):Void {
        this.setup();
        super.onCreate();
    }

    public override function onStateChangeEnd(event:StateChangeScriptEvent):Void {
        this.setup();
        super.onStateChangeEnd();
    }


    var freeplayState:FreeplayState = null;

    public override function onSubStateOpenEnd(event:SubStateScriptEvent):Void {
        if (Std.isOfType(event.targetState, FreeplayState)) {
            freeplayState = event.targetState;
        }
        super.onSubStateOpenEnd();
    }

    public override function onUpdate(event:UpdateScriptEvent):Void {
        if (freeplayState != null) {
            ArraySort.sort(freeplayState.diffIdsTotal,sortDifficulties);
            freeplayState = null;
        }
        super.onUpdate();
    }
}