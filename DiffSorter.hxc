// TODO: Add more comments to this file
import funkin.modding.module.Module;
import funkin.modding.module.ModuleHandler;
import funkin.modding.PolymodErrorHandler;
import funkin.Paths;
import funkin.ui.freeplay.FreeplayState;
import funkin.util.Constants;
// import funkin.util.StructureUtil;
import funkin.util.tools.ArrayTools;
import haxe.ds.ArraySort;
import haxe.Json;
import Int;
import openfl.utils.Assets;
import StringTools;

class DiffSorter extends Module {

    function new() {
        super('diff-sorter', 1);
    }

    // PLEASE DON'T MODIFY THESE VARIABLES!!!
    var SORTING_PATH_PREFIX:String = "UD/sort/";
    // for sorting a variation and its difficulties
    var VARI_PREFIX_SORTP:String = "variations/";
    // for sorting a difficulty independently
    var DIFFS_PREFIX_SORTP:String = "difficulties/";

    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    var difficultySorting:Array<Array<String>> = [
        ["easy","normal","hard","erect","nightmare"],
        ["1","3","5","1","3"]
    ];
    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    var variationSorting:Array<Array<String>> = [
        ["default","erect"],
        ["1","2"]
    ];

    var difficultiesToVariations:Array<Array<String>> = [[],[]];

    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    /**
     * Used for tracking setup completion.
     */
     var finishedSetup:Bool = false;

    function sortDifficulties(a:String, b:String):Int {
        var numAv:Int = Std.parseInt(this.variationSorting[1][this.variationSorting[0].indexOf(
            this.difficultiesToVariations[1][this.difficultiesToVariations[0].indexOf(a)]
        )]);
        var numBv:Int = Std.parseInt(this.variationSorting[1][this.variationSorting[0].indexOf(
            this.difficultiesToVariations[1][this.difficultiesToVariations[0].indexOf(b)]
        )]);
        if (numAv < numBv) {
            return -1;
        }
        if (numAv > numBv) {
            return 1;
        }
        var numAd:Int = Std.parseInt(this.difficultySorting[1][this.difficultySorting[0].indexOf(a)]);
        var numBd:Int = Std.parseInt(this.difficultySorting[1][this.difficultySorting[0].indexOf(b)]);
        if (numAd < numBd) {
            return -1;
        }
        if (numAd > numBd) {
            return 1;
        }
        return 0;
    }

    function checkForSortingData(path:String):Dynamic {
        if (!Assets.exists(path)) {return null;}
        var result = Json.parse(StringTools.trim(Assets.getText(path)));
        if (!Std.isOfType(result.index, Int)) {
            PolymodErrorHandler.showAlert("Difficulty Sorting Error",
                "The difficulty sorting data at "+path+" is invalid."+
                "\nthe index property must exist and be an integer.");
            return null;
        }
        return result;
    }

    function setup():Void {
        if (this.finishedSetup) {return;}

        // This is only used for reading
        // stuff and doesn't get modyfied.
        this.difficultiesToVariations = ModuleHandler.
            getModule("vari-injector").scriptGet("difficultiesToVariations");

        var sortingData:Dynamic;
        
        var allVariations:Array<String> = [];
        for (variationId in this.difficultiesToVariations[1]) {
            if (!allVariations.contains(variationId)) {
                allVariations.push(variationId);
            }
        }
        allVariations.remove("default");
        allVariations.remove("erect");

        for (variationId in allVariations) {
            var path:String = Paths.json(SORTING_PATH_PREFIX+VARI_PREFIX_SORTP+variationId);
            sortingData = checkForSortingData(path);
            if (sortingData == null) {continue;}
            this.variationSorting[0].push(variationId);
            this.variationSorting[1].push(Std.string(sortingData.index));
            // if (sortingData.difficultyIndices == null) {continue;}
            // var diffIndexMap = StructureUtil.toMap(sortingData.difficultyIndices);
            // for (difficultyId in diffIndexMap.keys()) {
            //     if (this.difficultiesToVariations[1][this.difficultiesToVariations[0]
            //         .indexOf(difficultyId)] != variationId)
            //     {
            //         PolymodErrorHandler.showAlert("Difficulty Sorting Error",
            //             "The difficulty sorting data at "+path+" is invalid."+
            //             "\nTried to sort a difficulty that doesn't belong to the variation.");
            //         continue;
            //     }
            //     var index = diffIndexMap[difficultyId];
            //     if (!Std.isOfType(index, Int)) {
            //         PolymodErrorHandler.showAlert("Difficulty Sorting Error",
            //             "The difficulty sorting data at "+path+" is invalid."+
            //             "\nan index in the difficultyIndices map wasn't an integer.");
            //         continue;
            //     }
            //     this.difficultySorting[0].push(difficultyId);
            //     this.difficultySorting[1].push(Std.string(index));
            // }
        }

        var allDifficulties:Array<String> = this.difficultiesToVariations[0].copy();
        allDifficulties.filter(function(difficultyId:String):Bool {
            return !this.difficultySorting[0].contains(difficultyId);
        });

        for (difficultyId in allDifficulties) {
            var path:String = Paths.json(SORTING_PATH_PREFIX+DIFFS_PREFIX_SORTP+difficultyId);
            sortingData = checkForSortingData(path);
            if (sortingData == null) {continue;}
            this.difficultySorting[0].push(difficultyId);
            this.difficultySorting[1].push(Std.string(sortingData.index));
        }

        Constants.DEFAULT_DIFFICULTY_LIST = this.difficultiesToVariations[0].copy();
        ArraySort.sort(Constants.DEFAULT_DIFFICULTY_LIST, sortDifficulties);

        trace('[diff-sorter]  -  Finished Sorting Difficulties');

        this.finishedSetup = true;
    }

    public override function onCreate(event:ScriptEvent):Void {
        super.onCreate();
        setup();
    }

    public override function onStateChangeEnd(event:StateChangeScriptEvent):Void {
        super.onStateChangeEnd();
        setup();
    }

    var freeplayState:FreeplayState = null;

    public override function onSubStateOpenEnd(event:SubStateScriptEvent):Void {
        super.onSubStateOpenEnd();
        if (Std.isOfType(event.targetState, FreeplayState)) {
            freeplayState = event.targetState;
        }
    }

    public override function onUpdate(event:UpdateScriptEvent):Void {
        super.onUpdate();
        if (freeplayState != null) {
            ArraySort.sort(freeplayState.diffIdsTotal,sortDifficulties);
            freeplayState = null;
        }
    }
}