// TODO: Add more comments to this file
import funkin.modding.module.Module;
import funkin.modding.module.ModuleHandler;
import funkin.modding.PolymodErrorHandler;
import funkin.Paths;
import funkin.ui.freeplay.FreeplayState;
import funkin.util.Constants;
import funkin.util.tools.ArrayTools;
import haxe.ds.ArraySort;
import Int;
import openfl.utils.Assets;
import StringTools;

class DiffSorter extends Module {

    function new() {
        super('diff-sorter', 1);
    }
    var VARI_DEF_PATH:String = "UD/variations";
    var DIFF_DEF_PATH:String = "UD/difficulties";

    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    var difficultySorting:Array<Array<String>> = [
        ["easy","normal","hard","erect","nightmare"],
        ["1","3","5","1","3"]
    ];
    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    var variationSorting:Array<Array<String>> = [
        ["default","erect"],
        ["1","2"]
    ];

    var difficultiesToVariations:Array<Array<String>> = [[],[]];

    // PLEASE DON'T MODIFY THIS VARIABLE!!!
    /**
     * Used for tracking setup completion.
     */
     var finishedSetup:Bool = false;

    function sortDifficulties(a:String, b:String):Int {
        var numAv:Null<Int> = Std.parseInt(this.variationSorting[1][this.variationSorting[0].indexOf(
            this.difficultiesToVariations[1][this.difficultiesToVariations[0].indexOf(a)]
        )]);
        var numBv:Null<Int> = Std.parseInt(this.variationSorting[1][this.variationSorting[0].indexOf(
            this.difficultiesToVariations[1][this.difficultiesToVariations[0].indexOf(b)]
        )]);
        if (numAv == null || numBv == null) {return 0;}
        if (numAv < numBv) {
            return -1;
        }
        if (numAv > numBv) {
            return 1;
        }

        var numAd:Null<Int> = Std.parseInt(this.difficultySorting[1][this.difficultySorting[0].indexOf(a)]);
        var numBd:Null<Int> = Std.parseInt(this.difficultySorting[1][this.difficultySorting[0].indexOf(b)]);
        if (numAd == null || numBd == null) {return 0;}
        if (numAd < numBd) {
            return -1;
        }
        if (numAd > numBd) {
            return 1;
        }
        return 0;
    }

    function checkForSortingData(path:String, callback:(res:Array<String>) -> Void):Void {
        if (!Assets.exists(path)) {return;}
        for (line in Assets.getText(path).split("\n")) {
            if (line == "") {continue;}
            if (StringTools.startsWith(line, "//")) {continue;}
            callback(line.split(',').map(function(e:String):String {return StringTools.trim(e);}));
        }
    }

    function setup():Void {
        if (this.finishedSetup) {return;}

        // This is only used for reading
        // stuff and doesn't get modyfied.
        this.difficultiesToVariations = ModuleHandler.
            getModule("vari-injector").scriptGet("difficultiesToVariations");

        var sortingData:Dynamic;
        
        var allVariations:Array<String> = [];
        for (variationId in this.difficultiesToVariations[1]) {
            if (!allVariations.contains(variationId)) {
                allVariations.push(variationId);
            }
        }
        allVariations.remove("default");
        allVariations.remove("erect");

        checkForSortingData(Paths.txt(VARI_DEF_PATH), function(res:Array<String>):Void {
            if (res.length < 1) {return;}

            // TODO: Remove this check after I change some 
            // stuff in the code base and make sure it's safe.
            if (!allVariations.contains(res[0])) {return;}

            if (res.length < 2) {res.push('');}

            this.variationSorting[0].push(res[0]);
            this.variationSorting[1].push(res[1].split(".")[0]);
        });

        var allDifficulties:Array<String> = this.difficultiesToVariations[0].copy();
        allDifficulties.filter(function(difficultyId:String):Bool {
            return !this.difficultySorting[0].contains(difficultyId);
        });

        checkForSortingData(Paths.txt(DIFF_DEF_PATH), function(res:Array<String>):Void {
            if (res.length < 2) {return;}

            // TODO: Remove these checks after I change some 
            // stuff in the code base and make sure it's safe.
            if (!allDifficulties.contains(res[0])) {return;}
            if (!this.difficultiesToVariations[1][this.difficultiesToVariations[0].indexOf(res[0])] == res[1]) {return;}

            if (res.length < 3) {res.push('');}

            this.difficultySorting[0].push(res[0]);
            this.difficultySorting[1].push(res[2].split(".")[0]);
        });

        Constants.DEFAULT_DIFFICULTY_LIST = this.difficultiesToVariations[0].copy();
        ArraySort.sort(Constants.DEFAULT_DIFFICULTY_LIST, sortDifficulties);

        trace('[diff-sorter]  -  Finished Sorting Difficulties');

        this.finishedSetup = true;
    }

    public override function onCreate(event:ScriptEvent):Void {
        super.onCreate();
        setup();
    }

    public override function onStateChangeEnd(event:StateChangeScriptEvent):Void {
        super.onStateChangeEnd();
        setup();
    }

    var freeplayState:FreeplayState = null;

    public override function onSubStateOpenEnd(event:SubStateScriptEvent):Void {
        super.onSubStateOpenEnd();
        if (Std.isOfType(event.targetState, FreeplayState)) {
            freeplayState = event.targetState;
        }
    }

    public override function onUpdate(event:UpdateScriptEvent):Void {
        super.onUpdate();
        if (freeplayState != null) {
            ArraySort.sort(freeplayState.diffIdsTotal,sortDifficulties);
            freeplayState = null;
        }
    }
}